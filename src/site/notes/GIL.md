---
{"dg-publish":true,"permalink":"/gil/","dgHomeLink":true,"dgPassFrontmatter":false}
---



> [GIL]([聊聊Python中的GIL - 青山牧云人 - 博客园 (cnblogs.com)](https://www.cnblogs.com/ArsenalfanInECNU/p/9968621.html))

# 一、GIL 是什么

GIL 全称 Global Interpreter Lock，全局解释器锁。

**做什么**：当执行多线程程序时，由 GIL 来控制同一时刻只有一个线程能够运行。

**为什么**：为了解决多线程之间数据完整性和状态同步的问题。

同一时刻只有一个线程能够运行，那么是怎么执行多线程程序的呢？其实原理很简单：**解释器的分时复用**。即多个线程的代码，轮流被解释器执行，只不过切换的很频繁很快，给人一种多线程“同时”在执行的错觉。聊的学术化一点，其实就是“**并发**”。

再拓展一点“并发”和“并行”的概念：

普通解释：  
并发：交替做不同事情的能力  
并行：同时做不同事情的能力  
专业术语：  
**并发：不同的代码块交替执行**  
**并行：不同的代码块同时执行**

那么问题来了，Python为什么要如此设计呢？即**为什么要保证同一时刻只有一个线程在解释器中运行呢**？

答案是为了**Python解释器中原子操作的线程安全**。

# 二、 线程安全与原子操作

## 1. 线程安全

进程是系统资源分配的最小单位，线程是程序执行的最小单位。

多线程环境中，共享数据同一时间只能有一个线程来操作 不然中间过程可能会产生不可预制的结果。

## 2. 原子操作

**原子操作就是不会因为进程并发或者线程并发而导致被中断的操作**。**原子操作**的特点就是**要么一次全部执行，要么全不执行**。不存在执行了一半而被中断的情况。

# 三、GIL 的优缺点

**GIL的优点是显而易见的，GIL可以保证我们在多线程编程时，无需考虑多线程之间数据完整性和状态同步的问题**。

**GIL缺点是：我们的多线程程序执行起来是“并发”，而不是“并行”。因此执行效率会很低，会不如单线程的执行效率。**

网上很多人都提到过这样的疑问：”**为什么我多线程Python程序运行得比其只有一个线程的时候还要慢**?“显然，大家觉得一个具有两个线程的程序要比其只有一个线程时要快。事实上,这个问题是确实存在的，原因在于GIL的存在使得Python多线程程序的执行效率甚至比不上单线程的执行效率。很简单，**由于GIL使得同一时刻只有一个线程在运行程序，再加上切换线程和竞争GIL带来的开销，显然Python多线程的执行效率就比不上单线程的执行效率了。**

# 四、如何规避 GIL 带来的影响

## 1. 多进程代替多线程

multiprocess库的出现很大程度上是为了弥补thread库因为GIL而低效的缺陷。它完整的复制了一套thread所提供的接口方便迁移。唯一的不同就是它使用了多进程而不是多线程。**每个进程有自己的独立的GIL，因此也不会出现进程之间的GIL争抢**。

当然multiprocess也不是万能良药。它的引入会增加程序实现时线程间数据通讯和同步的困难。就拿计数器来举例子，如果我们要多个线程累加同一个变量，对于thread来说，申明一个global变量，用thread.Lock的context包裹住三行就搞定了。而multiprocess由于进程之间无法看到对方的数据，只能通过在主线程申明一个Queue，put再get或者用share memory的方法。这个额外的实现成本使得本来就非常痛苦的多线程程序编码，变得更加痛苦了。

